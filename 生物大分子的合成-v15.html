<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DNA 单页交互 Z1.1（真镜像 + 精确点位 + 空心接口 + 边缘连线）</title>

<style>
  /* ========== 视觉主题（与你提供的版本保持一致，仅补充注释） ========== */
  :root{ --bg:#f8fafc; --ink:#0f172a; --board:#ffffff; }
  *{box-sizing:border-box}
  body{
    font-family:system-ui,Segoe UI,Helvetica,Arial;
    margin:18px; color:var(--ink); background:var(--bg);
  }
  h1{font-size:20px; margin:0 0 8px;}
  .hint{margin:6px 0 12px; color:#334155; font-size:13px;}

  /* 工作区与“物品栏” */
  .board{position:relative; width:100%; height:720px; background:var(--board);
         border:1px solid #e6edf3; border-radius:10px; overflow:hidden;}
  .palette{position:absolute; left:0; right:0; top:0; min-height:168px; background:#f1f5f9;
           border-bottom:1px dashed #cbd5e1; padding:10px 14px;}
  .pal-grid{display:grid; grid-template-columns: repeat(8, 190px); gap:12px;
            overflow-x:auto; padding-bottom:6px;}
  .legend{margin-top:6px; font-size:12px; color:#475569; display:flex; gap:16px; align-items:center;}
  .small-btn{margin:10px 8px 0 0; padding:6px 10px; border-radius:6px; border:1px solid #cbd5e1;
             background:#fff; cursor:pointer; font-size:12px;}

  /* ========== 无外框的“核苷酸卡片” ========== */
  .nuc{ position:absolute; width:190px; height:132px; cursor:grab; user-select:none; touch-action:none; }
  .nuc.dragging{ transform:scale(1.04); z-index:2000; cursor:grabbing; }

  /* 五碳糖（五边形）：固定居中，和你版式一致 */
  .nuc .sugar{
    position:absolute; width:72px; height:72px; top:34px; left:calc(50% - 36px);
    background:#fde68a; border:2px solid #b45309; border-radius:8px;
    /* 五边形路径：上顶点与左右顶点用于连线定位（见 JS 中的 v_tl / v_tr / v_ll） */
    clip-path: polygon(50% 0%, 100% 36%, 82% 100%, 18% 100%, 0 36%);
  }

  /* 磷酸（圆）：右向卡放左侧，左向卡放右侧 */
  .nuc .phos{
    position:absolute; width:42px; height:42px; top:16px; border-radius:50%;
    background:#fee2e2; border:2px solid #ef4444; color:#991b1b;
    display:flex; align-items:center; justify-content:center; font-weight:900;
  }
  .orient-R .phos{ left:10px; }  .orient-L .phos{ right:10px; }

  /* “端口”仅用于可视化标识；真正的精确坐标在 JS 里计算 */
  .port{ position:absolute; width:16px; height:16px; border-radius:50%;
         background:#fff; border:2px solid #0ea5e9; }
  .port::after{content:''; position:absolute; left:50%; top:50%;
               transform:translate(-50%,-50%); width:6px; height:6px; border-radius:50%;
               background:currentColor; opacity:.6}

  /* 5'/3' 小标签（仅用于提示） */
  .lbl{ position:absolute; font-size:10px; color:#475569;
        background:#f1f5f9; border:1px solid #cbd5e1; border-radius:6px; padding:2px 4px;}
  .orient-R .lbl.p{left:12px; top:-8px;} .orient-R .lbl.s{left:calc(50% - 26px); top:18px;}
  .orient-L .lbl.p{right:12px; top:-8px;} .orient-L .lbl.s{left:calc(50% - 26px); top:18px;}

  /* 碱基砖：palette 内靠近糖；克隆到画布后由 JS 外移（±CONFIG.OUT 像素） */
  .base{ position:absolute; top:64px; width:68px; height:28px;
         border-radius:6px; display:flex; align-items:center; justify-content:center; font-weight:900; color:#fff; }
  .orient-R .base{ right:10px; left:auto; }
  .orient-L .base{ left:10px;  right:auto; }
  .A{ background:#06b6d4; } .T{ background:#10b981; } .C{ background:#ef4444; } .G{ background:#eab308; color:#111827;}

  /* 碱基接口（peg=凸，socket=凹）：圆形对圆形、三角对三角；左右镜像 */
  /* 圆形接口 */
  .base[data-shape='circle'][data-side='right'][data-sex='peg']::after,
  .base[data-shape='circle'][data-side='left' ][data-sex='peg']::before{
    content:''; position:absolute; top:50%; transform:translateY(-50%);
    width:16px; height:16px; border-radius:50%; background:#111827; opacity:.9;
  }
  .base[data-shape='circle'][data-side='right'][data-sex='peg']::after{ right:-10px; }
  .base[data-shape='circle'][data-side='left' ][data-sex='peg']::before{ left:-10px; }
  .base[data-shape='circle'][data-side='right'][data-sex='socket']::after,
  .base[data-shape='circle'][data-side='left' ][data-sex='socket']::before{
    content:''; position:absolute; top:50%; transform:translateY(-50%);
    width:16px; height:16px; border-radius:50%; background:#fff; box-shadow:0 0 0 2px #111827 inset;
  }
  .base[data-shape='circle'][data-side='right'][data-sex='socket']::after{ right:-10px; }
  .base[data-shape='circle'][data-side='left' ][data-sex='socket']::before{ left:-10px; }

  /* 三角接口 */
  .base[data-shape='tri'][data-side='right'][data-sex='peg']::after{
    content:''; position:absolute; right:-12px; top:50%; transform:translateY(-50%);
    width:0; height:0; border-left:18px solid #111827; border-top:9px solid transparent; border-bottom:9px solid transparent;
  }
  .base[data-shape='tri'][data-side='left'][data-sex='peg']::before{
    content:''; position:absolute; left:-12px; top:50%; transform:translateY(-50%);
    width:0; height:0; border-right:18px solid #111827; border-top:9px solid transparent; border-bottom:9px solid transparent;
  }
  .base[data-shape='tri'][data-side='right'][data-sex='socket']::after{
    content:''; position:absolute; right:-12px; top:50%; transform:translateY(-50%);
    width:18px; height:18px; background:#fff; clip-path: polygon(0 0, 100% 50%, 0 100%); box-shadow:0 0 0 2px #111827 inset;
  }
  .base[data-shape='tri'][data-side='left' ][data-sex='socket']::before{
    content:''; position:absolute; left:-12px;  top:50%; transform:translateY(-50%);
    width:18px; height:18px; background:#fff; clip-path: polygon(100% 0, 0 50%, 100% 100%); box-shadow:0 0 0 2px #111827 inset;
  }

  /* 全局 SVG（画布层）与每个卡片内的 SVG（用于内部连线） */
  svg{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
  .intra{ position:absolute; left:0; top:0; width:190px; height:132px; pointer-events:none; overflow:visible; }

  /* “水滴”按钮（用于断开 5'-3' 键） */
  .water{
    position:absolute; padding:6px 10px; border-radius:6px;
    background:rgba(59,130,246,.12); border:1px solid rgba(59,130,246,.32);
    display:flex; align-items:center; justify-content:center; font-weight:800; color:#0369a1;
    user-select:none; cursor:pointer;
  }
</style>
</head>
<body>
  <h1>DNA 单页交互 Z1.1</h1>
  <p class="hint">
    说明：从上方“物品栏”拖拽会 <b>复制</b> 一个核苷酸到画布；碱基砖在画布里的克隆会
    <b>沿远离糖的方向外移</b>（默认 200px，可在脚本里改 <code>CONFIG.OUT</code>）。所有连线都严格接在<b>外边缘</b>。
    双击虚线可解除碱基配对；把“水滴”拖到键上可水解 5′→3′ 键。
  </p>

  <div class="board" id="board">
    <div class="palette">
      <div class="pal-grid" id="palgrid"></div>
      <div class="legend">
        <span>从这里拖拽 = 复制一个</span>
        <button class="small-btn" id="reset">重置画布</button>
      </div>
    </div>
    <svg id="svg"></svg>
  </div>

<script>
/* ============================ 配置区（可按需自行修改） ============================ */
const CONFIG = {
  OUT: 200,          // 碱基砖“画布克隆”后外移的距离（越大离糖越远）
  BOND_NEAR: 22,     // 成立 5'→3' 键的判定距离（端口“边缘”之间）
  PAIR_NEAR: 30,     // 配对虚线判定距离（碱基锚点之间）
  WATER_RANGE: 40    // 水滴靠近键的判定半径
};

/* ============================ 基础 DOM 与状态 ============================ */
(function(){
  const board = document.getElementById('board');
  const svg   = document.getElementById('svg');
  const pal   = document.getElementById('palgrid');

  // 画布上的实例：{id, el, pos:{x,y}, leftFree, rightFree, baseType, shape, sex, side, orient}
  const items = [];
  // 5'→3' 键：{l,r,line,rect,txt}
  const bonds = [];
  // “水滴”实例：{id, el}
  const waters = [];
  // 碱基配对：{a,b,line}
  const pairs = [];

  const CARD_W = 190, CARD_H = 132;

  /* ========== palette 数据模型（四碱基 × 2 真镜像） ========== */
  const v = (base,shape,sex) => ([
    {base, shape, sex, orient:'R', side:'right', title:`${base} · 右向 (P→S→B)`},
    {base, shape, sex, orient:'L', side:'left',  title:`${base} · 左向 (B→S→P)`}
  ]);
  const variants = [
    ...v('A','circle','peg'),
    ...v('T','circle','socket'),
    ...v('C','tri','peg'),
    ...v('G','tri','socket')
  ];

  /* ========== 生成“核苷酸卡片”DOM ========== */
  function makeNuc(cfg){
    const el = document.createElement('div'); el.className='nuc orient-'+cfg.orient; el.dataset.base=cfg.base; el.title=cfg.title;
    el.innerHTML = `
      <div class="phos">P</div>
      <div class="port p5" data-port="p5" title="5'-P"></div>
      <div class="sugar" title="五碳糖"></div>
      <div class="port oh" data-port="oh" title="3'-OH"></div>
      <div class="lbl p">5'</div>
      <div class="lbl s">3'</div>
      <div class="base ${cfg.base}" data-shape="${cfg.shape}" data-sex="${cfg.sex}" data-side="${cfg.side}">${cfg.base}</div>
      <svg class="intra"></svg>`;
    return el;
  }

  // 将 8 种（4 碱基 × 2 朝向）放到“物品栏”
  variants.forEach(cfg=>{
    const el=makeNuc(cfg);
    el.dataset.palette='1'; // 标记：在物品栏中
    el.style.position='relative';
    pal.appendChild(el);
    layoutNuc(el); // 初次布局（palette 中不外移碱基）
  });

  /* ========== 对单个卡片做“内部布局与连线” ========== */
  function layoutNuc(el){
    const orient = el.classList.contains('orient-L') ? 'L' : 'R';
    const sugar  = el.querySelector('.sugar');
    const phos   = el.querySelector('.phos');
    const oh     = el.querySelector('.port.oh');
    const p5     = el.querySelector('.port.p5');
    const base   = el.querySelector('.base');
    const intra  = el.querySelector('svg.intra');

    // palette 中不外移；画布克隆后按方向外移（±CONFIG.OUT）
    const isPalette = el.dataset.palette==='1';
    if(orient==='R'){ base.style.right = isPalette ? '10px' : (-CONFIG.OUT)+'px'; base.style.left='auto'; }
    else            { base.style.left  = isPalette ? '10px' : (-CONFIG.OUT)+'px'; base.style.right='auto'; }

    // —— 从五边形计算 3 个关键顶点 ——
    const sx=sugar.offsetLeft, sy=sugar.offsetTop, sw=sugar.offsetWidth, sh=sugar.offsetHeight;
    const v_tl={x:sx+0.00*sw, y:sy+0.36*sh};   // 左上 ≈ C5'
    const v_tr={x:sx+1.00*sw, y:sy+0.36*sh};   // 右上（镜像）
    const v_ll={x:sx+0.18*sw, y:sy+1.00*sh};   // 左下 ≈ C3'

    // 3'-OH 端口：放在 v_ll 的外边缘附近
    oh.style.left=(v_ll.x-7)+'px';
    oh.style.top =(v_ll.y-7)+'px';

    // 5'-P 端口：放在“磷酸圆顶”的中点
    const phx = phos.offsetLeft + phos.offsetWidth/2;
    const phy = phos.offsetTop; // 顶边
    p5.style.left = (phx - 8) + 'px';
    p5.style.top  = (phy - 8) + 'px';

    // 单元内部 SVG：绘制 P–S、S–OH、S–Base 三条“边缘到边缘”的线
    intra.setAttribute('viewBox',`0 0 ${CARD_W} ${CARD_H}`);
    while(intra.firstChild) intra.removeChild(intra.firstChild);

    // 1) P–S：从圆周边缘 → 糖顶点（R 用 v_tl；L 用 v_tr）
    const pcx = phos.offsetLeft + phos.offsetWidth/2;
    const pcy = phos.offsetTop  + phos.offsetHeight/2;
    const rc  = phos.offsetWidth/2; // 半径
    const STop = (orient==='R') ? v_tl : v_tr;
    const dx1 = STop.x - pcx, dy1 = STop.y - pcy; const len1 = Math.hypot(dx1,dy1)||1;
    const px1 = pcx + dx1/len1*(rc-2), py1 = pcy + dy1/len1*(rc-2);
    intra.appendChild(makeLine(px1,py1, STop.x,STop.y,'#ef4444',2)); // 红色细线

    // 2) S(左下)–OH：到端口“外边缘”
    const ohc={x:oh.offsetLeft+8, y:oh.offsetTop+8};
    const dx2=ohc.x - v_ll.x, dy2=ohc.y - v_ll.y; const len2=Math.hypot(dx2,dy2)||1;
    const ox2=ohc.x - dx2/len2*8, oy2=ohc.y - dy2/len2*8;
    intra.appendChild(makeLine(v_ll.x,v_ll.y, ox2,oy2,'#0ea5e9',2)); // 青色细线

    // 3) 糖—碱基：起点=糖上角（R→v_tr；L→v_tl），终点=碱基靠糖一侧“边界”
    const br = base.getBoundingClientRect(), er = el.getBoundingClientRect();
    const baseLeft = br.left - er.left, baseRight = br.right - er.left, baseMidY = br.top - er.top + br.height/2;
    const baseEdgeX = (orient==='R') ? baseLeft : baseRight;
    const sugarVertex = (orient==='R') ? v_tr : v_tl;
    intra.appendChild(makeLine(sugarVertex.x, sugarVertex.y, baseEdgeX, baseMidY, '#64748b', 2)); // 灰色细线
  }

  /* 画一条 SVG 线段（用于卡片内部） */
  function makeLine(x1,y1,x2,y2,stroke,w){
    const L=document.createElementNS('http://www.w3.org/2000/svg','line');
    L.setAttribute('x1',x1); L.setAttribute('y1',y1);
    L.setAttribute('x2',x2); L.setAttribute('y2',y2);
    L.setAttribute('stroke',stroke); L.setAttribute('stroke-width',w);
    L.setAttribute('stroke-linecap','round');
    return L;
  }

  /* ============================ 拖拽：克隆 / 移动 ============================ */
  let drag=null;
  const endDrag = ()=>{
    if(!drag) return;
    const el=document.querySelector(`.nuc[data-id="${drag.id}"]`);
    if(el) el.classList.remove('dragging');
    const A=items.find(a=>a.id===drag.id);

    // —— 尝试生成 5'→3' 键（采用“边缘到边缘”的距离判定） ——
    for(const B of items){ if(B.id===A.id) continue;
      if(near(getPort(A,'oh'),getPort(B,'p5'),CONFIG.BOND_NEAR) && A.rightFree && B.leftFree && !isBond(A.id,B.id)){ formPhos(A.id,B.id); break; }
      if(near(getPort(B,'oh'),getPort(A,'p5'),CONFIG.BOND_NEAR) && B.rightFree && A.leftFree && !isBond(B.id,A.id)){ formPhos(B.id,A.id); break; }
    }

    // —— 尝试 A/T、C/G 配对（接口形状与凹凸也要互补） ——
    for(const B of items){ if(B.id===A.id) continue; tryPair(A,B); tryPair(B,A); }

    drag=null;
  };

  board.addEventListener('pointerdown', (ev)=>{
    const card=ev.target.closest('.nuc'); if(!card) return;
    const rect=board.getBoundingClientRect();

    if(card.dataset.palette==='1'){
      // 从物品栏“复制”一个到画布
      const clone=card.cloneNode(true);
      clone.dataset.palette='0';
      clone.style.position='absolute';
      clone.style.left=(ev.clientX-rect.left-CARD_W/2)+'px';
      clone.style.top =(ev.clientY-rect.top -CARD_H/2)+'px';
      board.appendChild(clone);

      // 赋 id 与元信息（供成键/配对逻辑使用）
      const id='n'+Math.random().toString(36).slice(2);
      clone.dataset.id=id;
      layoutNuc(clone); // 注意：此时会把碱基外移 ±CONFIG.OUT

      const baseEl=clone.querySelector('.base');
      const meta={
        baseType:(clone.dataset.base||baseEl.textContent.trim()),
        shape:baseEl.dataset.shape, sex:baseEl.dataset.sex,
        side:baseEl.dataset.side, orient:clone.classList.contains('orient-L')?'L':'R'
      };
      items.push({id, el:clone, pos:{x:parseFloat(clone.style.left), y:parseFloat(clone.style.top)},
                  leftFree:true, rightFree:true, ...meta });

      // 进入拖拽态
      clone.setPointerCapture(ev.pointerId);
      drag={id, ox:CARD_W/2, oy:CARD_H/2};
      clone.classList.add('dragging');
    }else{
      // 拖动画布上的已存在实例
      const id=card.dataset.id; const it=items.find(a=>a.id===id);
      card.setPointerCapture(ev.pointerId);
      drag={id, ox:ev.clientX-rect.left-it.pos.x, oy:ev.clientY-rect.top-it.pos.y};
      card.classList.add('dragging');
    }
  });

  board.addEventListener('pointermove', (ev)=>{
    if(!drag) return;
    const r=board.getBoundingClientRect();
    const it=items.find(a=>a.id===drag.id);
    it.pos.x=ev.clientX-r.left-drag.ox;
    it.pos.y=ev.clientY-r.top -drag.oy;
    it.el.style.left=it.pos.x+'px';
    it.el.style.top =it.pos.y+'px';
    refresh(); // 实时刷新连线
  });

  // 多路兜底：确保能“放下”
  ['pointerup','pointercancel'].forEach(t=>board.addEventListener(t,endDrag));
  ['pointerup','pointercancel'].forEach(t=>document.addEventListener(t,endDrag));
  window.addEventListener('blur', endDrag);

  /* ============================ 端口/锚点/距离工具 ============================ */
  function getPort(it, which){
    // which==='oh' → 3'-OH；which==='p5' → 5'-P
    const el=it.el.querySelector(which==='oh'?'.port.oh':'.port.p5');
    const r=el.getBoundingClientRect(), wr=board.getBoundingClientRect();
    return {x:r.left+8-wr.left, y:r.top+8-wr.top}; // 取“端口圆心”
  }
  function baseAnchor(it){
    // 碱基配对的锚点：取碱基靠外的一侧边界中点
    const base=it.el.querySelector('.base');
    const br=base.getBoundingClientRect(), wr=board.getBoundingClientRect();
    const side = (it.side||base.dataset.side);
    return ( side==='right'
      ? {x:br.right-wr.left, y:br.top+br.height/2-wr.top}
      : {x:br.left -wr.left, y:br.top+br.height/2-wr.top} );
  }
  function near(a,b,t){ return Math.hypot(a.x-b.x,a.y-b.y) < t; }
  function edgeBetween(a,b,ra=8,rb=8){
    // 让线段接在“外边缘”而非中心（ra/rb≈端口半径）
    const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy)||1;
    return { x1:a.x + dx/d*ra, y1:a.y + dy/d*ra, x2:b.x - dx/d*rb, y2:b.y - dy/d*rb };
  }

  /* ============================ 刷新所有连线 ============================ */
  function refresh(){
    // 5'→3' 键
    bonds.forEach(b=>{
      const L=items.find(x=>x.id===b.l), R=items.find(x=>x.id===b.r);
      const A=getPort(L,'oh'), P=getPort(R,'p5');
      const e=edgeBetween(A,P,10,10);
      b.line.setAttribute('x1',e.x1); b.line.setAttribute('y1',e.y1);
      b.line.setAttribute('x2',e.x2); b.line.setAttribute('y2',e.y2);
      const mx=(e.x1+e.x2)/2, my=(e.y1+e.y2)/2;
      b.rect.setAttribute('x',mx-70); b.rect.setAttribute('y',my-16);
      b.txt .setAttribute('x',mx   ); b.txt .setAttribute('y',my+6);
    });

    // 碱基配对虚线
    pairs.forEach(p=>{
      const A=baseAnchor(items.find(x=>x.id===p.a));
      const B=baseAnchor(items.find(x=>x.id===p.b));
      p.line.setAttribute('x1',A.x); p.line.setAttribute('y1',A.y);
      p.line.setAttribute('x2',B.x); p.line.setAttribute('y2',B.y);
    });
  }

  /* ============================ 5'→3' 键 与 水解 ============================ */
  function isBond(l,r){ return bonds.some(b=>b.l===l && b.r===r); }

  function formPhos(l,r){
    const L=items.find(a=>a.id===l), R=items.find(a=>a.id===r);
    L.rightFree=false; R.leftFree=false;

    const A=getPort(L,'oh'), P=getPort(R,'p5');
    const e=edgeBetween(A,P,10,10);

    const line=svgLine(e.x1,e.y1,e.x2,e.y2,'#0ea5e9',5);
    const rect=svgRect((e.x1+e.x2)/2-70,(e.y1+e.y2)/2-16,140,28,6,'#2563eb');
    const txt =svgText((e.x1+e.x2)/2,(e.y1+e.y2)/2+6,"磷酸二酯键 5'→3'");
    bonds.push({l,r,line,rect,txt});

    // 生成“水滴”以便水解
    const w=makeWater(((e.x1+e.x2)/2)-28,((e.y1+e.y2)/2)-46);
    w.addEventListener('pointerup',()=>{
      const mx=(e.x1+e.x2)/2, my=(e.y1+e.y2)/2;
      const wx=parseFloat(w.style.left)+16, wy=parseFloat(w.style.top)+8;
      if(Math.hypot(wx-mx,wy-my)<CONFIG.WATER_RANGE){
        [line,rect,txt].forEach(e=>e.remove());
        L.rightFree=true; R.leftFree=true;
        const i=bonds.findIndex(b=>b.l===l&&b.r===r); if(i>=0) bonds.splice(i,1);
        w.remove();
      }
    });
  }

  /* ============================ 碱基配对（AT/CG，接口互补） ============================ */
  function isPaired(a,b){ return pairs.some(p=>(p.a===a && p.b===b)||(p.a===b && p.b===a)); }
  function isComplement(a,b){ return (a==='A'&&b==='T')||(a==='T'&&b==='A')||(a==='C'&&b==='G')||(a==='G'&&b==='C'); }

  function tryPair(a,b){
    const shapeOK=a.shape===b.shape;          // 圆对圆 / 三角对三角
    const sexOK  =a.sex!==b.sex;              // 凸对凹
    const faceOK =(a.side==='right'&&b.side==='left') || (a.side==='left'&&b.side==='right');
    if(!(shapeOK && sexOK && faceOK && isComplement(a.baseType,b.baseType))) return;

    const A=baseAnchor(a), B=baseAnchor(b);
    if(Math.hypot(A.x-B.x, A.y-B.y) < CONFIG.PAIR_NEAR && !isPaired(a.id,b.id)){
      const line=svgLine(A.x,A.y,B.x,B.y,'#94a3b8',3);
      line.setAttribute('stroke-dasharray','6 6');
      pairs.push({a:a.id, b:b.id, line});
      // 双击虚线可“拆对”
      line.addEventListener('dblclick',()=>{
        const i=pairs.findIndex(p=>(p.a===a.id&&p.b===b.id)||(p.a===b.id&&p.b===a.id));
        if(i>=0){ pairs[i].line.remove(); pairs.splice(i,1); }
      });
    }
  }

  /* ============================ 画布层 SVG/水滴工具函数 ============================ */
  function svgLine(x1,y1,x2,y2,stroke,w){
    const L=document.createElementNS('http://www.w3.org/2000/svg','line');
    L.setAttribute('x1',x1); L.setAttribute('y1',y1);
    L.setAttribute('x2',x2); L.setAttribute('y2',y2);
    L.setAttribute('stroke',stroke); L.setAttribute('stroke-width',w);
    L.setAttribute('stroke-linecap','round');
    svg.appendChild(L); return L;
  }
  function svgRect(x,y,w,h,r,fill){
    const R=document.createElementNS('http://www.w3.org/2000/svg','rect');
    R.setAttribute('x',x); R.setAttribute('y',y);
    R.setAttribute('width',w); R.setAttribute('height',h);
    R.setAttribute('rx',r); R.setAttribute('fill',fill);
    svg.appendChild(R); return R;
  }
  function svgText(x,y,str){
    const T=document.createElementNS('http://www.w3.org/2000/svg','text');
    T.setAttribute('x',x); T.setAttribute('y',y);
    T.setAttribute('text-anchor','middle');
    T.setAttribute('font-size','12'); T.setAttribute('font-weight','700'); T.setAttribute('fill','#fff');
    T.textContent=str; svg.appendChild(T); return T;
  }
  function makeWater(x,y){
    // 生成一个可拖拽“水滴”元素（双击可删除）
    const id='w'+Math.random().toString(36).slice(2);
    const el=document.createElement('div'); el.className='water';
    el.style.left=x+'px'; el.style.top=y+'px'; el.textContent='H₂O'; el.dataset.id=id;
    board.appendChild(el); waters.push({id, el});

    let drag=null;
    el.addEventListener('pointerdown',(e)=>{
      e.stopPropagation(); el.setPointerCapture(e.pointerId);
      const rect=board.getBoundingClientRect();
      drag={ox:e.clientX-rect.left-parseFloat(el.style.left), oy:e.clientY-rect.top-parseFloat(el.style.top)};
    });
    board.addEventListener('pointermove',(e)=>{
      if(!drag) return;
      const rect=board.getBoundingClientRect();
      el.style.left=(e.clientX-rect.left-drag.ox)+'px';
      el.style.top =(e.clientY-rect.top -drag.oy)+'px';
    });
    el.addEventListener('pointerup',()=>{ drag=null; });
    el.addEventListener('dblclick',()=>{
      el.remove();
      const i=waters.findIndex(w=>w.id===id); if(i>=0) waters.splice(i,1);
    });
    return el;
  }

  /* ============================ 重置 ============================ */
  document.getElementById('reset').addEventListener('click', ()=>{
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    items.forEach(it=>it.el.remove()); items.length=0;
    bonds.length=0; waters.forEach(w=>w.el.remove()); waters.length=0;
    pairs.forEach(p=>p.line.remove()); pairs.length=0;
  });
})();
</script>
</body>
</html>
